# 14. Exceptions

## Chapter title
**Robust Error Handling**

## Learning goals
- Use `try`, `catch`, and `throw`
- Create custom exception types
- Choose between exceptions and error codes

## üìñ READ

### 1. What is this concept?
Exceptions are a mechanism for handling errors without mixing error-handling code into every line of logic. When something goes wrong, you can ‚Äúthrow‚Äù an exception. The program then searches for the nearest `catch` block that can handle it.

This allows normal code paths to stay clean and readable, while error handling is centralized in fewer places.

### 2. Why does this exist?
Before exceptions, programmers used error codes. That required checking return values after every operation, which made code messy and often led to mistakes when checks were skipped.

Exceptions exist to:
- Separate error handling from normal logic
- Force errors to be addressed at some level
- Provide rich error information

C++ needs exceptions because it supports large systems where error handling must be robust and consistent.

### 3. How it works under the hood
When you throw an exception, the runtime begins **stack unwinding**. It destroys objects in the current scope (calling destructors) and walks up the call stack until it finds a matching catch block.

If no catch is found, the program calls `std::terminate` and ends. Exception handling requires metadata generated by the compiler to know where catch blocks are and how to unwind safely.

### 4. Mental model
Think of exceptions like emergency alarms in a building. Normal operations continue until an alarm is triggered. When it is, everyone follows the evacuation path (stack unwinding) until they reach a safety officer who handles the situation (catch block).

### 5. Common mistakes beginners make
- Throwing exceptions for normal control flow (like ‚Äúend of file‚Äù)
- Catching by value, which slices exception objects
- Swallowing exceptions without logging or handling them
- Forgetting that destructors run during stack unwinding

### 6. When NOT to use this
- Avoid exceptions for predictable, frequent events (use error codes or optional values)
- Avoid exceptions in performance-critical inner loops
- Some low-level or embedded environments disable exceptions for size/performance reasons

Use exceptions for unexpected, exceptional conditions, not for routine outcomes.

### 7. How this connects to other topics
Exceptions connect to RAII because destructors run during stack unwinding. They also connect to file I/O, memory management, and system programming where errors are common. In modern C++, `std::optional` and `std::expected` (C++23) provide alternatives in some cases.

## Theory explanation
Exceptions separate error handling from normal logic. When an error occurs, the program can `throw` an exception which unwinds the stack until a matching `catch` is found. Use exceptions for exceptional conditions, not normal control flow.

## Code examples (C++)
```cpp
double safeDivide(double a, double b) {
    if (b == 0.0) {
        throw std::runtime_error("Division by zero");
    }
    return a / b;
}

try {
    std::cout << safeDivide(10, 0) << "\n";
} catch (const std::exception &e) {
    std::cerr << "Error: " << e.what() << "\n";
}
```

## Common mistakes
- Throwing exceptions for expected conditions (like normal EOF)
- Catching by value instead of by reference
- Swallowing exceptions and hiding errors

## Homework (easy / medium / hard)
1. (Easy) Throw an exception when input is negative.
2. (Easy) Catch `std::exception` and print the message.
3. (Easy) Create a custom exception class.
4. (Medium) Validate file opening and throw on failure.
5. (Medium) Build a calculator that throws on invalid operations.
6. (Medium) Compare error codes vs exceptions in a short note.
7. (Hard) Create a small exception hierarchy for a library system.

## Mini-project (when applicable)
**"Safe Calculator"**  
Build a calculator that uses exceptions for invalid operations and logs errors.
